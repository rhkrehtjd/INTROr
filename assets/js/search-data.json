{
  
    
        "post0": {
            "title": "데이터 처리 연습",
            "content": "키보드 직접 데이터 입력받기 | . num &lt;- scan() . 파이썬에서의 input()과 동일하다. | 다만 주피터 노트북에서는 실행이 안 되고 Rstudio에서 가능한 것 같다. | 입력된 데이터는 입력된 순서대로 벡터 변수 num에 저장된다. | . name &lt;- scan(what = character()) . 키보드로 문자를 입력하기 위함이다. | 입력한 문자는 순서대로 name 벡터로 저장된다. | . . df = data.frame() df = edit(df) . 데이터 입력을 돕기 위해 표 형식의 데이터 편집기를 제공한다. | Rstudio에서 실행시 사용할 수 있다. | . . 파일에 저장된 데이터를 불러오기 | . read.table() 테이블(칼럼이 모여서 레코드 구성) 형태로 작성되어 있으며, 칼럼이 공백, 탭, 콜론, 세미콜론, 콤마 등으로 구분된 자료 파일을 불러올 수 있는 함수이다. | 만약 구분자가 공백이거나 탭이면 sep 속성을 생략할 수 있다. 또한 칼럼명이 있는 경우 header 속성은 TRUE로 지정한다. | . | . getwd() # 현재 작업 디렉토리의 경로 확인 . &#39;C:/Users/ehfus/Downloads/R&#39; setwd(&#39;C:/Users/ehfus/Downloads/R&#39;) # 작업 디렉토리 설정 . student &lt;- read.table(file = &#39;first.txt&#39;) . student # 칼럼명이 없을 경우 기본으로 V1~으로 설정된다. . A data.frame: 4 × 4 V1V2V3V4 . &lt;int&gt;&lt;int&gt;&lt;int&gt;&lt;int&gt; . 101 | 1 | 1 | 1 | . 101 | 1 | 1 | 1 | . 101 | 1 | 1 | 1 | . 101 | 1 | 1 | 1 | . names(student)&lt;-c(&#39;a&#39;,&#39;a2&#39;,&#39;a3&#39;,&#39;a4&#39;) student . A data.frame: 4 × 4 aa2a3a4 . &lt;int&gt;&lt;int&gt;&lt;int&gt;&lt;int&gt; . 101 | 1 | 1 | 1 | . 101 | 1 | 1 | 1 | . 101 | 1 | 1 | 1 | . 101 | 1 | 1 | 1 | . . student &lt;- read.table(file = &#39;second.txt&#39;,sep=&#39;,&#39;,header=T,encoding=&quot;UTF-8&quot; ) . student . A data.frame: 4 × 4 번호이름성별몸무게 . &lt;chr&gt;&lt;chr&gt;&lt;chr&gt;&lt;chr&gt; . 10 | 1 | 1 | 1 | . 10 | 1 | 1 | 1 | . 10 | 1 | 1 | 1 | . sd | ad | ad | ad | . student &lt;- read.table(file = &#39;second.txt&#39;) . student . A data.frame: 3 × 1 V1 . &lt;chr&gt; . 10,1,1,1 | . 10,1,1,1 | . sd,ad,ad,ad | . 구분자 입력 안 해줘서 10,1,1,1이 하나의 요소로 해석된 모양이다 | . . 탐색기를 통해서 파일 선택하기 | . student &lt;- read.table(file.choose(),sep=&#39;,&#39;,header=T,encoding=&quot;UTF-8&quot;) . student . A data.frame: 4 × 4 번호이름성별몸무게 . &lt;chr&gt;&lt;chr&gt;&lt;chr&gt;&lt;chr&gt; . 10 | 1 | 1 | 1 | . 10 | 1 | 1 | 1 | . 10 | 1 | 1 | 1 | . sd | ad | ad | ad | . 파일에 특정 문자열을 NA로 처리하여 파일을 불러올 수 있다. na.strings = &#39;-&#39;를 통해 처리할 수 있다. | . | . . 엑셀에서는 작업한 파일을 R에서 처리할 수 있도록 CSV 형식으로 변환하여 저장할 수 있다. | CSV(comma separation valule) 파일 형식은 콤마를 기준으로 각 칼럼을 구분하여 저장한 데이터 형식을 말한다. | sep=&#39;,&#39;가 기본값이며, header=T가 기본값이다. 따라서 칼럼명이 있는 경우에 header속성은 생략할 수 있다. | . read.csv(file = &#39;third.csv&#39;,encoding=&quot;UTF-8&quot;) . A data.frame: 2 × 4 X.U.FEFF.asasdasdasd.1곽 . &lt;int&gt;&lt;int&gt;&lt;int&gt;&lt;int&gt; . 1 | 123 | 1234 | 123 | . 1234 | 214 | 124 | 24 | . csv파일 형식이 아닌 엑셀 파일(.xlsx)을 직접 R에서 불러올 수도 있다. | 엑셀 파일은 일반 파일과는 달리 시트(sheet) 단위로 자료를 저장한다. 따라서 엑셀 파일을 읽을 때는 시트명과 셀의 범위를 지정해서 읽는다. | . install.packages(&#39;readxl&#39;) library(readxl) . package &#39;readxl&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users ehfus AppData Local Temp RtmpEH2tA1 downloaded_packages . 기본함수가 아니기 때문에 위와 같은 셀이 필요하다 | . read_excel(path=&#39;fourth.xlsx&#39;,sheet=&#39;fourth&#39;) . New names: * asd -&gt; asd...2 * asd -&gt; asd...3 . A tibble: 2 × 4 asasdasd...2asd...3곽 . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 1 | 123 | 1234 | 123 | . 1234 | 214 | 124 | 24 | . . 인터넷에서 파일 가져오기 인터넷에서 제공하는 CSV 파일 형식의 데이터를 해당 사이트에서 직접 R 스트립트로 가져와서 데이터를 가공 처리한 후 분석에 활용할 수 있다. | 99p를 참고하자 | . | .",
            "url": "https://rhkrehtjd.github.io/INTROr/2022/02/07/r.html",
            "relUrl": "/2022/02/07/r.html",
            "date": " • Feb 7, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "data.frame, List, stringr",
            "content": "data.frame 객체 자료 처리 함수 | . df = data.frame(x=1:5, y=seq(1,9,2),z=c(&#39;abfa&#39;,&#39;aavd&#39;,&#39;avs&#39;,&#39;S&#39;,&#39;S&#39;)) df . A data.frame: 5 × 3 xyz . &lt;int&gt;&lt;dbl&gt;&lt;chr&gt; . 1 | 1 | abfa | . 2 | 3 | aavd | . 3 | 5 | avs | . 4 | 7 | S | . 5 | 9 | S | . str(df) # 데이터 프레임의 구조를 보여준다. . &#39;data.frame&#39;: 5 obs. of 3 variables: $ x: int 1 2 3 4 5 $ y: num 1 3 5 7 9 $ z: chr &#34;abfa&#34; &#34;aavd&#34; &#34;avs&#34; &#34;S&#34; ... . 5 obs. of 3 variables : 5개의 관측치와 3개의 변수로 구성됨 | . ncol(df) . 3 nrow(df) . 5 names(df) . &lt;ol class=list-inline&gt;&#39;x&#39; | &#39;y&#39; | &#39;z&#39; | &lt;/ol&gt; df[c(2,3),1] # R은 파이썬과 달리 index가 1부터 시작함! . &lt;ol class=list-inline&gt;2 | 3 | &lt;/ol&gt; df[1] # 첫 번째 열 . A data.frame: 5 × 1 x . &lt;int&gt; . 1 | . 2 | . 3 | . 4 | . 5 | . summary(df) # 요약 통계량을 볼 수 있다. # 숫자로 구성된 칼럼에 대해서만 수행된다. . x y z Min. :1 Min. :1 Length:5 1st Qu.:2 1st Qu.:3 Class :character Median :3 Median :5 Mode :character Mean :3 Mean :5 3rd Qu.:4 3rd Qu.:7 Max. :5 Max. :9 . df[,c(1,2)] . A data.frame: 5 × 2 xy . &lt;int&gt;&lt;dbl&gt; . 1 | 1 | . 2 | 3 | . 3 | 5 | . 4 | 7 | . 5 | 9 | . df[c(1,2)] . A data.frame: 5 × 2 xy . &lt;int&gt;&lt;dbl&gt; . 1 | 1 | . 2 | 3 | . 3 | 5 | . 4 | 7 | . 5 | 9 | . apply(df[,c(1,2)],2,sum) . &lt;dl class=dl-inline&gt;x15y25&lt;/dl&gt; apply(df[c(1,2)],2,sum) . &lt;dl class=dl-inline&gt;x15y25&lt;/dl&gt; 데이터프레임의 부분 객체 만들기 데이터 프레임 객체의 데이터를 대상으로 조건에 만족하는 행을 추출하여 독립된 객체를 생성할 수 있다. | . | . x1 &lt;- subset(df,x&gt;=3) x1 . A data.frame: 3 × 3 xyz . &lt;int&gt;&lt;dbl&gt;&lt;chr&gt; . 33 | 5 | avs | . 44 | 7 | S | . 55 | 9 | S | . 행 기준이다. | . x2 &lt;- subset(df, x&gt;=2 &amp; y&lt;=6) x2 . A data.frame: 2 × 3 xyz . &lt;int&gt;&lt;dbl&gt;&lt;chr&gt; . 22 | 3 | aavd | . 33 | 5 | avs | . 이렇게 두 개의 조건으로 부분 객체를 만들 수도 있다. | . . sid = c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;) score = c(12,123,13,5) subject = c(&#39;컴퓨터1&#39;,&#39;컴퓨터2&#39;,&#39;컴퓨터3&#39;,&#39;컴퓨터4&#39;) student = data.frame(sid ,score, subject) student . A data.frame: 4 × 3 sidscoresubject . &lt;chr&gt;&lt;dbl&gt;&lt;chr&gt; . a | 12 | 컴퓨터1 | . b | 123 | 컴퓨터2 | . c | 13 | 컴퓨터3 | . d | 5 | 컴퓨터4 | . mode(student) class(student) . &#39;list&#39; &#39;data.frame&#39; str(sid);str(score);str(subject);str(student) # 벡터 자료구조와 데이터 프레임 자료구조 . chr [1:4] &#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;d&#34; num [1:4] 12 123 13 5 chr [1:4] &#34;컴퓨터1&#34; &#34;컴퓨터2&#34; &#34;컴퓨터3&#34; &#34;컴퓨터4&#34; &#39;data.frame&#39;: 4 obs. of 3 variables: $ sid : chr &#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;d&#34; $ score : num 12 123 13 5 $ subject: chr &#34;컴퓨터1&#34; &#34;컴퓨터2&#34; &#34;컴퓨터3&#34; &#34;컴퓨터4&#34; . . h &lt;- data.frame(id = c(1,2), height = c(123,1234)) w &lt;- data.frame(id2 = c(1,2), weight = c(123,43)) . h;w . A data.frame: 2 × 2 idheight . &lt;dbl&gt;&lt;dbl&gt; . 1 | 123 | . 2 | 1234 | . A data.frame: 2 × 2 id2weight . &lt;dbl&gt;&lt;dbl&gt; . 1 | 123 | . 2 | 43 | . merge(h,w,by.x=&#39;id&#39;,by.y=&#39;id2&#39;) . A data.frame: 2 × 3 idheightweight . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 1 | 123 | 123 | . 2 | 1234 | 43 | . by.x=&#39;id&#39;,by.y=&#39;id2&#39; -&gt; 병합 시에 기준이 되는 칼럼명이 상이할 때 사용함 | . . install.packages(&#39;UsingR&#39;) # 패키지 설치 library(UsingR) # 패키지 로드 data(galton) # galton 데이터 셋 가져오기 . package &#39;UsingR&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users ehfus AppData Local Temp RtmpYpStoY downloaded_packages . Loading required package: MASS Loading required package: HistData Loading required package: Hmisc Loading required package: lattice Loading required package: survival Loading required package: Formula Loading required package: ggplot2 Attaching package: &#39;Hmisc&#39; The following objects are masked from &#39;package:base&#39;: format.pval, units Attaching package: &#39;UsingR&#39; The following object is masked from &#39;package:survival&#39;: cancer . str(galton) . &#39;data.frame&#39;: 928 obs. of 2 variables: $ child : num 61.7 61.7 61.7 61.7 61.7 62.2 62.2 62.2 62.2 62.2 ... $ parent: num 70.5 68.5 65.5 64.5 64 67.5 67.5 67.5 66.5 66.5 ... . dim(galton) . &lt;ol class=list-inline&gt;928 | 2 | &lt;/ol&gt; head(galton, 5) . A data.frame: 5 × 2 childparent . &lt;dbl&gt;&lt;dbl&gt; . 161.7 | 70.5 | . 261.7 | 68.5 | . 361.7 | 65.5 | . 461.7 | 64.5 | . 561.7 | 64.0 | . . List 자료구조 List는 성격이 다른 자료형(문자열, 숫자형, 논리형)과 자료구조(벡터, 행렬, 리스트, 데이터 프레임)를 객체로 생성할 수 있다. | 하나의 메모리 영역에는 키과 값이 한 쌍 | Python의 dict 자료구조와 유사하다. | list 생성 함수 : list() | list 자료 처리 함수 : unlist(), lapply(), sapply() | list는 키와 값을 한 쌍으로 하여 원소가 저장되는 자료구조이다. 만약 키를 생략하면 자동으로 기본 키가 생성된다. | . | . list1 &lt;- list(&#39;lee&#39;,&#39;lee2&#39;,95) # list 객체 생성 list1 . &#39;lee&#39; | &#39;lee2&#39; | 95 | key를 지정하지 않아서 임의로 지정됐음 | list 객체는 키를 통해서 값이 저장되기 때문에 서로 다른 자료형을 저장할 수 있다. list와 data.frame은 상이한 자료형을 혼합할 수 있다. | . | . list를 vector로 변경해보자 | . unlist &lt;- unlist(list1) unlist . &lt;ol class=list-inline&gt;&#39;lee&#39; | &#39;lee2&#39; | &#39;95&#39; | &lt;/ol&gt; 리스트 자료구조에 다량의 데이터가 저장되는 경우 리스트 형태로 출력하면 여러 줄로 출력되기 때문에 벡터 형식으로 변환할 경우 자료 처리가 용이해진다. | character &gt; numeric &gt; logical 순서로 벡터에 저장되기 때문에 전부 character로 변환하여 반환되었음 | . list2 &lt;- list(c(1:5),c(5:1)) list2 . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; | &lt;ol class=list-inline&gt;5 | 4 | 3 | 2 | 1 | &lt;/ol&gt; | list3 &lt;- list(matrix(1:6,2),array(1:12,c(3,2,2))) list3 . A matrix: 2 × 3 of type int 1 | 3 | 5 | . 2 | 4 | 6 | . | &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | &lt;/ol&gt; | 이렇게 list 객체의 value에 저장될 수 있는 자료구조는 VECTOR 뿐만이 아니라 matrix 혹은 array도 가능하다. | . . key 명명하자 | . list4 &lt;- list(name = c(&#39;홍길동&#39;,&#39;유관순&#39;), age = c(1234,1245)) list4 . $name &lt;ol class=list-inline&gt;&#39;홍길동&#39; | &#39;유관순&#39; | &lt;/ol&gt; $age &lt;ol class=list-inline&gt;1234 | 1245 | &lt;/ol&gt; list4$name list4$name[2] . &lt;ol class=list-inline&gt;&#39;홍길동&#39; | &#39;유관순&#39; | &lt;/ol&gt; &#39;유관순&#39; list4$age list4$age[1] . &lt;ol class=list-inline&gt;1234 | 1245 | &lt;/ol&gt; 1234 list4$age[1]&lt;-1245 # 원소 수정 가능 list4$newkey &lt;- &#39;asdf&#39; # 새로운 키 추가 list4$newkey[c(1,2)] &lt;- c(124,1255) # 새롭게 추가 된 키에 새로운 value 추가 . list4 . $name &lt;ol class=list-inline&gt;&#39;홍길동&#39; | &#39;유관순&#39; | &lt;/ol&gt; $age &lt;ol class=list-inline&gt;1245 | 1245 | &lt;/ol&gt; $newkey &lt;ol class=list-inline&gt;&#39;124&#39; | &#39;1255&#39; | &lt;/ol&gt; length(list4) length(list4$name) mode(list4) class(list4) . 3 2 &#39;list&#39; &#39;list&#39; list4$new&lt;- NULL . list4 . $name &lt;ol class=list-inline&gt;&#39;홍길동&#39; | &#39;유관순&#39; | &lt;/ol&gt; $age &lt;ol class=list-inline&gt;1245 | 1245 | &lt;/ol&gt; $newkey &lt;ol class=list-inline&gt;&#39;124&#39; | &#39;1255&#39; | &lt;/ol&gt; 일부 key와 value 제거 | . list4 &lt;- NULL . list4 . NULL . 모두 제거 | . . 리스트 객체의 자료 처리 함수 | . a = list(c(1:5)) b = list(c(6:10)) lapply(c(a,b),max) # 리스트 객체에 max 함수 적용 . 5 | 10 | lapply() 함수는 두 개의 리스트 객체 a와 b를 대상으로 max() 함수를 적용하여 각 리스트 객체의 자료 중에서 가장 큰 값을 리스트 형태로 반환한다. | 동일한 결과를 벡터 형식으로 반환해보자 | . sapply(c(a,b),max) . &lt;ol class=list-inline&gt;5 | 10 | &lt;/ol&gt; lapply()는 연산 결과를 리스트 형태로 반환하지만, sapply()는 결과를 벡터형식으로 반환하기 때문에 많은 원소를 포함하고 있는 리스트 객체를 보다 효과적으로 처리할 수 있다. | . . 다차원 리스트 객체를 생성해보자 리스트 자료구조에 또 다른 리스트가 중첩된 자료구조를 다차원 리스트라고 한다. | 즉 value가 list이다 | . | . complex = list(c1 = list(1,2,3), c2 = list(4,5,6), c3 = list(7,8,9)) complex . $c1 1 | 2 | 3 | $c2 4 | 5 | 6 | $c3 7 | 8 | 9 | complex$c1 . 1 | 2 | 3 | 다차원 리스트를 열 단위로 바인딩하기 | . do.call(cbind, complex) . A matrix: 3 × 3 c1c2c3 . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 1 | 4 | 7 | . 2 | 5 | 8 | . 3 | 6 | 9 | . class(do.call(cbind, complex)) . &lt;ol class=list-inline&gt;&#39;matrix&#39; | &#39;array&#39; | &lt;/ol&gt; do.call(rbind, complex) . A matrix: 3 × 3 c11 | 2 | 3 | . c24 | 5 | 6 | . c37 | 8 | 9 | . class(do.call(rbind, complex)) . &lt;ol class=list-inline&gt;&#39;matrix&#39; | &#39;array&#39; | &lt;/ol&gt; 3개의 value를 구성하는 list 자료가 열 단위로 묶여서 matrix 객체가 생성된다. 특히 do.call() 함수는 다차원 리스트를 구성하는 리스트를 각각 분해한 후 지정된 함수(cbind 또는 rbind)를 호출하여 리스트 자료를 처리하는 데 효과적이다. | . . 텍스트 자료나 SNS에서 가공 처리된 빅데이터를 처리하기 위해서는 필요한 문자열을 적절하게 자르고 교체하고 추출하는 작업이 중요하다. 문자열을 효과적으로 처리하는 stringr 패키지에 대해 알아보자 | . install.packages(&#39;stringr&#39;) library(stringr) . Warning message: &#34;package &#39;stringr&#39; is in use and will not be installed&#34; . str_extract(&quot;홍길동35이순신45유관순25&quot;,&quot;[1-9]{2}&quot;) str_extract_all(&quot;홍길동35이순신45유관순25&quot;,&quot;[1-9]{2}&quot;) . &#39;35&#39; &lt;ol class=list-inline&gt;&#39;35&#39; | &#39;45&#39; | &#39;25&#39; | &lt;/ol&gt; | str_extract() 함수는 지정된 문자열을 대상으로 정규 표현식 &#39;[1-9]{2}&#39;의 패턴(숫자 2개가 연속된 경우)과 일치하는 가장 처음에 발견된 문자열을 추출해준다. | str_extract_all는 지정된 문자열을 대상으로 정규 표현식 &#39;[1-9]{2}&#39;의 패턴(숫자 2개가 연속된 경우)과 일치하는 모든 문자열을 추출해준다. | . . 정규 표현식 문자열 처리 관련 함수는 대부분 정규표현식을 이용하여 문자열의 패턴을 검사하고 해당 문자열을 대상으로 문자열을 교체하거나 추출하게 된다. 정규표현식은 약속된 기호인 메타문자들에 의해 표현된다. | . | . 반복 관련 정규 표현식 []기호는 대괄호 안의 문자가 한 번만 반복되고, {n}은 n만큼 반복된다. 예를 들면 [a-z]의 정규 표현식은 영문 소문자 a에서 z까지 범위 중에서 한 개의 영문 소문자를 의미하고 [a-z]{3}은 영문 소문자가 연속으로 3개 발생한다는 의미이다. | . | . | . string = &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlek.&#39; . str_extract_all(string, &#39;[a-z]{4}&#39;) # 영문 소문자가 4글자 연속하는 경우 추출 . &lt;ol class=list-inline&gt;&#39;rhkr&#39; | &#39;ehtj&#39; | &#39;ddms&#39; | &#39;rhdq&#39; | &#39;nfmf&#39; | &#39;xhde&#39; | &#39;kfgk&#39; | &#39;rjtd&#39; | &lt;/ol&gt; | str_extract_all(string, &#39;[a-z]{4,}&#39;) # 영문 소문자가 4글자 **이상** 연속하는 경우 추출 . &lt;ol class=list-inline&gt;&#39;rhkrehtjddms&#39; | &#39;rhdqnfmf&#39; | &#39;xhdekfgkf&#39; | &#39;rjtdlek&#39; | &lt;/ol&gt; | str_extract_all(string, &#39;[a-z]{3,5}&#39;) # 영문 소문자가 4글자 **이상** 5글자 **이하** 연속하는 경우 추출 . &lt;ol class=list-inline&gt;&#39;rhkre&#39; | &#39;htjdd&#39; | &#39;rhdqn&#39; | &#39;fmf&#39; | &#39;xhdek&#39; | &#39;fgkf&#39; | &#39;rjtdl&#39; | &lt;/ol&gt; | str_extract_all(string, &#39;rhkrehtjd&#39;) # 해당 문자열 추출 . &#39;rhkrehtjd&#39; | str_extract_all(string,&#39;2&#39;) # 해당 숫자 추출 . &#39;2&#39; | str_extract_all(string,&#39;[가-힣]{2,}&#39;) # 연속된 3개 이상의 한글 문자열 추출 . &#39;곽도성&#39; | 대문자 추출할 땐 [A-Z]를 이용한다. | 제외할 땐 [^a-z] | 영문자는 일단 제외하고 남은 것중 4글자 추출 [^a-z]{4} , 남은 것중 문자종류 상관없이 4글자 추출 | . | . . 한 개의 숫자와 단어 관련 정규표현식 | . jm = &#39;12344-125215&#39; str_extract(jm,&#39;[0-9]{5}-[0-9]{2,}&#39;) . &#39;12344-125215&#39; str_extract_all(jm,&#39; d{5}- d{6}&#39;) . &#39;12344-125215&#39; | string = &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.&#39; . str_extract_all(string,&#39; w{3,}&#39;) # 3글자 이상의 단어만 추출, 허나 특수문자는 포함하지 않는다. . &lt;ol class=list-inline&gt;&#39;rhkrehtjddms123&#39; | &#39;rhdqnfmf444&#39; | &#39;Rh곽도성&#39; | &#39;xhdekfgkf&#39; | &#39;rjtdlekrhkrehtjd&#39; | &lt;/ol&gt; | str_length(string) . 64 str_locate(string,&#39;rhkrehtjd&#39;) # 문자열 내에서 특정 문자열의 모든 위치의 index 시작과 끝 str_locate_all(string,&#39;rhkrehtjd&#39;) . A matrix: 1 × 2 of type int startend . 1 | 9 | . A matrix: 2 × 2 of type int startend . 1 | 9 | . 55 | 63 | . | . 부분 문자열 만들기 | . string . &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.&#39; sub = str_sub(string,1,length(string)-20) sub . &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf&#39; 대소문자 변경 | . change = str_to_upper(string) change . &#39;RHKREHTJDDMS123 DL RHDQNFMF444 RH곽도성 XHDEKFGKF RJTDLEKRHKREHTJD.&#39; change = str_to_lower(string) change . &#39;rhkrehtjddms123 dl rhdqnfmf444 rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.&#39; 문자열 교체 | . string . &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.&#39; rep1 = str_replace(string,&#39;123&#39;,&#39;dl&#39;) rep1 # 123을 dl로 변경 . &#39;rhkrehtjddmsdl dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.&#39; 문자열 결합 | . str_c(string,rep1) . &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.rhkrehtjddmsdl dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.&#39; str_c(string,&#39;1111111111111&#39;) . &#39;rhkrehtjddms123 dl rhdqnfmf444 Rh곽도성 xhdekfgkf rjtdlekrhkrehtjd.1111111111111&#39; 문자열 분리 | . a=str_split(string,&#39;r&#39;) # r기준으로 문자열 분리 a . &lt;ol class=list-inline&gt;&#39;&#39; | &#39;hk&#39; | &#39;ehtjddms123 dl &#39; | &#39;hdqnfmf444 Rh곽도성 xhdekfgkf &#39; | &#39;jtdlek&#39; | &#39;hk&#39; | &#39;ehtjd.&#39; | &lt;/ol&gt; | mode(a) class(a) . &#39;list&#39; &#39;list&#39; 문자열 합치기 | . new = c(&#39;asd&#39;,&#39;asdadfd&#39;,&#39;asds&#39;,&#39;aqefsd&#39;) # 콤마를 기준으로 문자열 벡터 합치자 join = paste(new,collapse = &#39;,&#39;) join . &#39;asd,asdadfd,asds,aqefsd&#39; 벡터 객체로 반환해준다 | 예를 들면 문자열 100개가 1개씩 우너소를 차지하는 벡터 객체를 대상으로 paste()함수를 적용하여 1개의 원소로 축소가 가능하다. | 따라서 방대한 자료를 분석하기 위해서 실습 예에서와 같은 방법으로 처리 단위를 축소한다면 빅데이터를 효율적으로 처리할 수 있다. | .",
            "url": "https://rhkrehtjd.github.io/INTROr/2022/02/06/r.html",
            "relUrl": "/2022/02/06/r.html",
            "date": " • Feb 6, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Vector & Matrix & Array 자료구조",
            "content": "연속된 1차원의 선형구조의 형태로 만들어짐 | 같은 자료형의 데이터만 저장할 수 있다. | 첫 번째 셀에서 정수와 문자를 혼합하여 저장했지만 반환되는 건 모두 문자로 변환되어 반환된다. | 첫 번째 셀과 두 번째 셀을 비교해보자 | . df=c(1,2,&#39;ㅁㄴㅇ&#39;) df . &lt;ol class=list-inline&gt;&#39;1&#39; | &#39;2&#39; | &#39;ㅁㄴㅇ&#39; | &lt;/ol&gt; df_=c(1,2,3) df_ . &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; 벡터 생성 함수 : c(), seq(), rep() | 벡터 자료 처리 함수 : union(), setdiff(), intersect() | . c(1:10) 1:10 c(1,2,3,4,5,6,7,8,9,10) . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | &lt;/ol&gt; seq(1,10,3) # 1부터 10까지 3씩 증가 . &lt;ol class=list-inline&gt;1 | 4 | 7 | 10 | &lt;/ol&gt; rep(1:3,3) . &lt;ol class=list-inline&gt;1 | 2 | 3 | 1 | 2 | 3 | 1 | 2 | 3 | &lt;/ol&gt; rep(1,3) . &lt;ol class=list-inline&gt;1 | 1 | 1 | &lt;/ol&gt; rep(1:3,each=2) # 각 자료가 반복 . &lt;ol class=list-inline&gt;1 | 1 | 2 | 2 | 3 | 3 | &lt;/ol&gt; 벡터 자료 처리 | . x&lt;-c(1,2,3,4) y&lt;-c(2,3) union(x,y) # 합집합 setdiff(x,y) # x-y . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 4 | &lt;/ol&gt; setdiff(y,x) # y-x는 남는 게 없음 . intersect(x,y) # 교집합 . &lt;ol class=list-inline&gt;2 | 3 | &lt;/ol&gt; 변수에 다양한 형식의 벡터 자료를 저장할 수 있다. 하지만 벡터 자료는 같은 유형의 자료만 하나의 변수에 저장할 수 있다. | 만약 숫자형과 문자형 또는 논리형이 혼합되는 경우에는 데이터 유형이 변경될 수 있다. | . v&lt;-c(T,TRUE,F,FALSE) v v&lt;-c(T,TRUE,F,FALSE,1) v v&lt;-c(T,TRUE,F,FALSE,1,&#39;1&#39;) v . &lt;ol class=list-inline&gt;TRUE | TRUE | FALSE | FALSE | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 1 | 0 | 0 | 1 | &lt;/ol&gt; &lt;ol class=list-inline&gt;&#39;TRUE&#39; | &#39;TRUE&#39; | &#39;FALSE&#39; | &#39;FALSE&#39; | &#39;1&#39; | &#39;1&#39; | &lt;/ol&gt; character &lt;- numeric &lt;- logical 순으로 우선순위를 두고 변경 됨 | R에서는 세미콜론(;)을 구분자로하여 한 줄에 여러 개의 R 스크립트 명령문을 사용할 수 있음 | . age=c(30,40,50) age names(age)=c(&#39;곽도성의 나이&#39;,&#39;곽도성2의 나이&#39;,&#39;곽도성3의 나이&#39;) age age&lt;-NULL # NaN은 되긴 하지만 NULL과 의미가 다른가? age . &lt;ol class=list-inline&gt;30 | 40 | 50 | &lt;/ol&gt; &lt;dl class=dl-inline&gt;곽도성의 나이30곽도성2의 나이40곽도성3의 나이50&lt;/dl&gt; NULL . 위 셀처럼 벡터 객체의 값에 칼럼명 지정 | . a&lt;-c(1:12) a[1:5] . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; 파이썬은 index 0번이 첫 번째 원소를 뜻하지만 R에서는 index 1이 첫 번째 원소를 뜻한다. | . length(a) . 12 벡터 객체에서 첨자를 이용하여 원소를 조회할 경우 c() 함수의 인수에 콤마를 사용할 수 있다. 이때 콤마는 1차원 자료구조에서 하나의 원소를 지정하는 역할을 한다. | . c1&lt;-c(1,2,3,4,2:5) c1 c1[c(1,3)] c1[c(1:3)] . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 3 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 2 | 3 | &lt;/ol&gt; 위 셀처럼 벡터 객체의 원소를 참조하기 위해서 c() 함수의 인수로 콤마와 콜론(:)을 이용할 수 있다. 콤마는 개별 원소 하나씩 지정하며 콜론은 원소의 범위를 지정하는 역할을 한다. | . c1 . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 2 | 3 | 4 | 5 | &lt;/ol&gt; c1[-1] c1[-c(2,4)] c1[c(-2,-4)] c1[c(-2:-4)] c1[c(-4:-1)] . &lt;ol class=list-inline&gt;2 | 3 | 4 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 3 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 3 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;ol class=list-inline&gt;2 | 3 | 4 | 5 | &lt;/ol&gt; index를 음수값으로 지정하는 경우에는 여집합의 개념으로 해당 첨자가 제외된다. 벡터 객체를 대상으로 위 셀처럼 c1[-1]을 지정할 경우 1번째만 제외하고 나머지 모든 벡터 자료가 반환된다. | . . Matrix : 동일한 자료형을 갖는 2차원의 배열구조를 갖는다. | 행과 열의 2차원 배열구조의 객체를 생성한다. | 동일한 타입의 데이터만 저장할 수 있다. | 행렬 생성 함수 : matrix(),rbind(),cbind() | 행렬 자료 처리 함수 :apply() | . m=matrix(c(1:5)) m . A matrix: 5 × 1 of type int 1 | . 2 | . 3 | . 4 | . 5 | . 위 셀처럼 matrix() 함수에서 c() 함수를 인수로 지정하여 matrix 객체를 생성할 수 있다. c() 함수는 기본적으로 열을 기준으로 객체를 만들어준다. | . m=matrix(1:10,nrow=2) m m=matrix(c(1:10),nrow=2) m . A matrix: 2 × 5 of type int 1 | 3 | 5 | 7 | 9 | . 2 | 4 | 6 | 8 | 10 | . A matrix: 2 × 5 of type int 1 | 3 | 5 | 7 | 9 | . 2 | 4 | 6 | 8 | 10 | . 이렇게 일단 열 기준임! | . m=matrix(c(1:11),nrow=3) m . Warning message in matrix(c(1:11), nrow = 3): &#34;데이터의 길이[11]가 행의 개수[3]의 배수가 되지 않습니다&#34; . A matrix: 3 × 4 of type int 1 | 4 | 7 | 10 | . 2 | 5 | 8 | 11 | . 3 | 6 | 9 | 1 | . 자료의 개수와 행과 열이 맞아 떨어지지 않으면 알아서 broadcast하여 채워 넣음 | . 벡터 데이터를 대상으로 행렬 객체를 생성하면 기본적으로 열 우선으로 데이터가 생성된다. | 행 우선으로 데이터를 생성해보자 | . m=matrix(1:10,nrow=2,byrow = T) m m=matrix(1:10,nrow=2,byrow = TRUE) m . A matrix: 2 × 5 of type int 1 | 2 | 3 | 4 | 5 | . 6 | 7 | 8 | 9 | 10 | . A matrix: 2 × 5 of type int 1 | 2 | 3 | 4 | 5 | . 6 | 7 | 8 | 9 | 10 | . 행 또는 열 묶음으로 행렬 객체 생성해보자 | . x1&lt;-c(1,2,3,6:10) x2&lt;-c(1,2,3,5:1) . bond&lt;-rbind(x1,x2) bond bond&lt;-cbind(x1,x2) bond . A matrix: 2 × 8 of type dbl x11 | 2 | 3 | 6 | 7 | 8 | 9 | 10 | . x21 | 2 | 3 | 5 | 4 | 3 | 2 | 1 | . A matrix: 8 × 2 of type dbl x1x2 . 1 | 1 | . 2 | 2 | . 3 | 3 | . 6 | 5 | . 7 | 4 | . 8 | 3 | . 9 | 2 | . 10 | 1 | . 각각 8개로 개수가 맞아서 rbind가 잘 됐음 | 개수 안 맞으면 bind 안 됨 | . . matrix() 함수에 직접 인수를 적용하여 행렬 객체를 생성할 수 있다. | matrix() 함수의 형식은 다음과 같다.matrix(data=NA,nrow =1, ncol=1, byrow=TRUE,dimnames=NULL) . | . m3=matrix(10:19,2) m3 . A matrix: 2 × 5 of type int 10 | 12 | 14 | 16 | 18 | . 11 | 13 | 15 | 17 | 19 | . mode(m3) class(m3) . &#39;numeric&#39; &lt;ol class=list-inline&gt;&#39;matrix&#39; | &#39;array&#39; | &lt;/ol&gt; index를 이용하여 행렬 객체에 접근하기 | . m3[1,] # 1행 m3[,3] # 3열 m3[1,3] # 1행 3열 m3[1,2:4] . &lt;ol class=list-inline&gt;10 | 12 | 14 | 16 | 18 | &lt;/ol&gt; &lt;ol class=list-inline&gt;14 | 15 | &lt;/ol&gt; 14 &lt;ol class=list-inline&gt;12 | 14 | 16 | &lt;/ol&gt; matrix(1:9,nrow=3,byrow=T) . A matrix: 3 × 3 of type int 1 | 2 | 3 | . 4 | 5 | 6 | . 7 | 8 | 9 | . 행렬 객체 자료 처리 함수 | . length(m3) # 원소 개수 ncol(m3) # 열 개수 nrow(m3) # 행 개수 . 10 5 2 apply() 함수는 행렬 구조의 자료를 처리하는 데 유용한 함수이다. | 함수 사용법 : apply(행렬객체, 1:행 or 2:열, 행렬 자료에 적용할 함수) | . m3 . A matrix: 2 × 5 of type int 10 | 12 | 14 | 16 | 18 | . 11 | 13 | 15 | 17 | 19 | . apply(m3,1,max) apply(m3,2,max) apply(m3,1,mean) . &lt;ol class=list-inline&gt;18 | 19 | &lt;/ol&gt; &lt;ol class=list-inline&gt;11 | 13 | 15 | 17 | 19 | &lt;/ol&gt; &lt;ol class=list-inline&gt;14 | 15 | &lt;/ol&gt; 당연히 사용자 정의 함수도 apply()에 사용할 수 있을 것이다. | . 이건 파이썬에서 함수 정의하는 방법이고def f(x): return(x+2) . | 이건 R에서 함수 정의하는 방법f &lt;- function(x){ x*c(1,2,3)} . | . f &lt;- function(x){ x*3} . m3 . A matrix: 2 × 5 of type int 10 | 12 | 14 | 16 | 18 | . 11 | 13 | 15 | 17 | 19 | . apply(m3,1,f) # 행 우선 순위로 f함수 적용 # 벡터 데이터 연산할 때 열 단위로 결과 출력 # 벡터 자료와 연산하면 기본적으로 열 우선 순서로 출력된다. # 이러한 행렬 구조를 전치행렬이라고 한다. . A matrix: 5 × 2 of type dbl 30 | 33 | . 36 | 39 | . 42 | 45 | . 48 | 51 | . 54 | 57 | . apply(m3,2,f) . A matrix: 2 × 5 of type dbl 30 | 36 | 42 | 48 | 54 | . 33 | 39 | 45 | 51 | 57 | . . 벡터 객체 에서 이름 지정하기 | . age=c(30,40,50) age names(age)=c(&#39;곽도성의 나이&#39;,&#39;곽도성2의 나이&#39;,&#39;곽도성3의 나이&#39;) age . &lt;ol class=list-inline&gt;30 | 40 | 50 | &lt;/ol&gt; &lt;dl class=dl-inline&gt;곽도성의 나이30곽도성2의 나이40곽도성3의 나이50&lt;/dl&gt; 행렬 객체에서 이름 지정하기 | . m3 . A matrix: 2 × 5 of type int 10 | 12 | 14 | 16 | 18 | . 11 | 13 | 15 | 17 | 19 | . colnames(m3)=c(12,3,4,5,5) m3 . A matrix: 2 × 5 of type int 123455 . 10 | 12 | 14 | 16 | 18 | . 11 | 13 | 15 | 17 | 19 | . . Array 자료구조 : 같은 자료형을 갖는 다차원 배열구조를 갖는다. | 행, 열, 면의 3차원 배열 형태의 객체를 생성한다. | 다른 자료구조에 비해서 상대적으로 활용도가 낮다. | 배열 생성 함수 : array() &lt;*apply()와 혼동 주의&gt; | . vec=c(1:12) arr &lt;- array(vec,c(3,2,2)) arr # 3행 2열 2면 생성 . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | &lt;/ol&gt; arr[,,1] # 1면 조회 arr[,,2] # 2먼 조회 . A matrix: 3 × 2 of type int 1 | 4 | . 2 | 5 | . 3 | 6 | . A matrix: 3 × 2 of type int 7 | 10 | . 8 | 11 | . 9 | 12 | . mode(arr) class(arr) . &#39;numeric&#39; &#39;array&#39; . DataFrame 자료구조 : R에서 가장 많이 활용 데이터 베이스의 테이블 구조와 유사하다. | 칼럼 단위로 서로 다른 데이터의 저장이 가능 | 리스트와 벡터의 혼합형으로 칼럼은 리스트, 칼럼 내의 데이터는 벡터 자료 구조를 갖는다. | 데이터프레임 생성함수 : data.frame(),read.table(), read.csv() | 데이터프레임 자료 처리 함수 : str(), ncol(), nrow(), apply(), summary(), subset() | . | . 데이터 프레임은 열 단위로 서로 다른 자료형을 포함할 수 있어서 벡터와 행렬을 이용하여 데이터 프레임 객체를 생성할 수 있다. | 기존의 데이터 파일을 불러와서 데이터 프레임 객체를 생성할 수도 있다. | 사용법 : data.frame(칼럼1=자료, 칼럼2=자료, ...) | . 벡터를 이용한 데이터 프레임 객체 생성 . no &lt;- c(1:3) name &lt;- c(&#39;k&#39;,&#39;b&#39;,&#39;s&#39;) pay &lt;- c(150, 200, 300) vemp &lt;- data.frame(칼럼1 = no, 칼럼2 = name, 칼럼3 = pay) vemp . A data.frame: 3 × 3 칼럼1칼럼2칼럼3 . &lt;int&gt;&lt;chr&gt;&lt;dbl&gt; . 1 | k | 150 | . 2 | b | 200 | . 3 | s | 300 | . vemp[1,1] . 1 여러 개의 벡터 객체를 이용하여 데이터 프레임을 생성할 수 있다. | 이때 각 벡터 객체의 칼럼 길이는 동일해야한다. | . 매트릭스를 이용한 데이터프레임 객체 생성 . m=matrix(c(1,&quot;k&quot;,150, 2,&#39;b&#39;,200, 3,&#39;s&#39;,250) ,3,by=T) memp=data.frame(m) memp . A data.frame: 3 × 3 X1X2X3 . &lt;chr&gt;&lt;chr&gt;&lt;chr&gt; . 1 | k | 150 | . 2 | b | 200 | . 3 | s | 250 | . memp[1,1] . &#39;1&#39; vemp[1,1] . 1 애초에 매트릭스를 이용해 데이터 프레임 객체를 생성할 때 매트릭스는 동일한 자료밖에 안 되기에 안의 원소가 전부 character로 변경됐었지만 vemp는 상이한 벡터 객체들을 데이터 프레임을 통해서 모아놓은 것이기 떄문에 자료형이 변하지 않고 유지되었음 | . df = data.frame(x=1:5, y=seq(1,9,2),z=c(&#39;abfa&#39;,&#39;aavd&#39;,&#39;avs&#39;,&#39;S&#39;,&#39;S&#39;)) df . A data.frame: 5 × 3 xyz . &lt;int&gt;&lt;dbl&gt;&lt;chr&gt; . 1 | 1 | abfa | . 2 | 3 | aavd | . 3 | 5 | avs | . 4 | 7 | S | . 5 | 9 | S | . 데이터 프레임의 칼럼명 참조하기 | . df$x df$y df$z . &lt;ol class=list-inline&gt;1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;ol class=list-inline&gt;1 | 3 | 5 | 7 | 9 | &lt;/ol&gt; &lt;ol class=list-inline&gt;&#39;abfa&#39; | &#39;aavd&#39; | &#39;avs&#39; | &#39;S&#39; | &#39;S&#39; | &lt;/ol&gt; $는 데이터 프레임에선 칼럼을 의미하며 리스트에서는 키를 의미한다. | .",
            "url": "https://rhkrehtjd.github.io/INTROr/2022/02/05/r.html",
            "relUrl": "/2022/02/05/r.html",
            "date": " • Feb 5, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "변수,자료형,기본 함수, 작업공간",
            "content": "변수는 분석에 필요한 자료를 일시적으로 저장하거나 처리결과를 담을 수 있는 기억장소를 지정해주는 역할을 한다. 즉 변수의 이름은 값을 저장하는 메모리 영역의 이름으로 할당된다. 또한 R은 모든 변수가 객체(object) 형태로 생성되기 때문에 하나의 변수에 자료와 함수 그리고 차트와 같은 이미지까지 모든 형식을 저장할 수 있다. 변수 이름 작성 규칙 첫 자는 영문자로 시작 | 두 번째 단어는 숫자와 밑줄 문자 그리고 점(.)을 이용할 수 있다. | 대문자와 소문자는 서로 다른 변수로 인식한다. | 변수 이름은 의미를 파악할 수 있는 이름으로 지정하는 것이 좋다. | 두 단어를 포함하여 변수 이름을 지정할 경우 두 번째 단어의 첫 자는 대문자로 표기한다. | 한 번 정의된 변수는 재사용이 가능하고 가장 최근에 할당된 값으로 수정된다. | . | . | . var1 &lt;- 0 var1 = 9 . var1 . 9 = 나 &lt;- 둘 다 사용가능하다 | . . 스칼라 변수 : 한 개의 값만 갖는 변수를 의미한다. | 벡터 변수 : 두 개 이상의 값을 갖는 변수를 의미한다. 여러 개의 자료를 저장할 수 있는 1차원의 선형 자료구조이다. | . | . age&lt;-35 # 정수 name&lt;-&#39;홍길동&#39; # 문자열 age;name name&lt;-c(&#39;홍길동&#39;,&#39;이순신&#39;,&#39;곽도성&#39;) # 이건 두 개 이상의 값을 갖는 변수, 여러 개의 자료를 저장할 수 있는 1차원의 선형 자료구조 # 즉 벡터변수 . 35 &#39;홍길동&#39; . R은 변수를 선언할 때 별도의 자료형(type)을 선언하지 않는다. 즉 변수에 저장하는 자료의 유형에 의해서 변수의 타입이 결정된다! 숫자형 : 정수, 실수 | 문자형 : 문자, 문자열 | 논리형 : 참, 거짓 | 결측 데이터 : 결측치, 비숫자(NA,NaN) | . | . int&lt;-20 string&lt;-&#39;홍길동&#39; boolean&lt;-TRUE # True파이썬에서는 이렇게 작성해야 함 . sum(10,20,30) # 3개의 숫자형 값의 합계 연산 . 60 sum(10,20,30,NA) # sum 안 됨 sum(10,20,30,NA,na.rm=TRUE) # na.rm=TRUE를 통해 NA 결측치 제거 후 합계 연산 . &lt;NA&gt; 60 ls() . &lt;ol class=list-inline&gt;&#39;age&#39; | &#39;boolean&#39; | &#39;int&#39; | &#39;name&#39; | &#39;string&#39; | &#39;var1&#39; | &lt;/ol&gt; . 자료형 확인 변수에 저장된 자료형을 확인하는 함수를 이용하여 반환되는 TRUE 또는 FALSE의 결과를 통해서 해당 변수의 자료형을 확인할 수 있다. | is.numeric(x) - 수치형 여부 | is.logical(x) | is.character(x) - 문자형 여부 | is.data.frame(x) - 데이터프레임 여부 | is.na(x) | is.integer(x) - 정수형 여부 | is.double(x) - 실수형 여부 | is.complex(x) | is.factor(x) - 범주형 여부 | is.nan(x) | . | . is.character(string) . TRUE . 자료형 변환 변수에 저장된 자료형을 다른 자료형으로 변환하자 as.numeric(x) - 수치형 변환 | as.logical(x) | as.character(x) - 문자형 변환 | as.data.frame(x) - 데이터프레임 변환 | as.list(x) - 리스트형 변환 | as.array(x) - 다차원 배열 변환 | as.integer(x) - 정수형 변환 | as.double(x) - 실수형 변환 | as.complex(x) | as.factor(x) - 요인형 변환 | as.Data(x) - 날짜형 변환 | . | . | . x&lt;-c(1,2,&#39;3&#39;) # 3개의 원소를 갖는 벡터 생성 # x*3 # 이렇게 작성하면 이항연산자에 수치가 아닌 인수가 있다는 error가 발생하게 됨 result&lt;-as.numeric(x)*3 result2&lt;-as.integer(x)*3 result result2 . &lt;ol class=list-inline&gt;3 | 6 | 9 | &lt;/ol&gt; &lt;ol class=list-inline&gt;3 | 6 | 9 | &lt;/ol&gt; c() 함수를 이용하여 벡터를 생성할 경우 원소 중 한 개라도 문자이면 모든 원소를 문자로 하여 객체가 생성된다. 따라서 이항연산자에 수치가 아닌 인수가 있다는 error가 발생하게 된다. | . . 복소수 | . z&lt;-5.3-3i Re(z) # 실수 Im(z) # 허수 is.complex(z) . 5.3 -3 TRUE as.complex(123) . 123+0i . 자료형과 자료구조 보기 자료형은 변수에 저장된 자료의 성격(숫자형, 문자형, 논리형)을 의미하고, 자료구조는 변수에 저장된 자료의 메모리 구조(배열, 리스트, 테이블)를 의미한다. 메모리 구조는 객체가 생성될 때 만들어지기 때문에 자료구조를 객체형(Object Type)이라고도 한다. R에서는 mode()를 이용하여 자료형을 확인할 수 있고, class()를 이용하여 자료 구조, 즉 메모리 구조를 확인할 수 있다. | . | . int&lt;-3 mode(int) # 자료의 성격을 알려준다. class(int) # 자료구조의 성격을 알려준다. . &#39;numeric&#39; &#39;numeric&#39; 이처럼 벡터 변수가 아닌 스칼라 변수일 땐 자료의 성격을 알려주는 mode()와 자료 구조의 성격을 알려주는 class() 함수의 결과는 같은 유형으로 나타난다. | . . 요인(Factor)형 변환 요인(Factor)은 같은 성격인 값의 목록을 범주로 갖는 벡터 자료를 의미한다. 범주는 변수가 가질 수 있는 값의 범위로 예를 들면 성별 변수의 범주는 남자와 여자가 되낟. 요인형은 순서에 의미가 없는 Nominal 유형과 순서에 의미가 있는 Ordinal 유형으로 구분된다. Nominal : 범주의 순서는 알파벳 순서로 정렬 | Ordinal : 범주의 순서는 사용자가 지정한 순서대로 정렬 | . | . | . gender&lt;- c(&#39;man&#39;,&#39;woman&#39;,&#39;woman&#39;,&#39;man&#39;,&#39;man&#39;) # plot(gender) # error 발생, 차트는 수치 데이터만 가능하다. . Factor Nominal : 벡터 원소를 요인형으로 변환한 경우 범주의 순서가 알파벳 순서로 정렬되는 요인형의 기본 유형이다. | . Ngender&lt;-as.factor(gender) # Factor형 변환 . Ngender . &lt;ol class=list-inline&gt;man | woman | woman | man | man | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt;&#39;man&#39; | &#39;woman&#39; | &lt;/ol&gt; 여기서 Levels가 의미하는 것이 범주이다. 여기서 범주의 수준(Levels)은 값의 목록을 알파벳 순서로 정렬한다. | . table(Ngender) # 빈도수 구하기 . Ngender man woman 3 2 . gender 원소 중에서 같은 값의 수량을 수치화한 빈도수를 확인할 수 있다. 여기서 man과 woman은 범주가 된다. 범주가 된다는 의미는 gender 변수가 값을 가질 수 잇는 범위를 의미한다. 또한 빈도수는 해당 범주의 발생 수를 의미한다. | . plot(Ngender) . mode(Ngender) class(Ngender) is.factor(Ngender) . &#39;numeric&#39; &#39;factor&#39; TRUE . - Factor Ordinal : &#48276;&#51452;&#51032; &#49692;&#49436;&#47484; &#49324;&#50857;&#51088;&#44032; &#51648;&#51221;&#54620; &#49692;&#49436;&#45824;&#47196; &#51221;&#47148;&#54616;&#45716; &#44592;&#45733;&#51004;&#47196; factor() &#54632;&#49688;&#51032; &#54805;&#49885;&#51008; &#45796;&#51020;&#44284; &#44057;&#45796;. . factor(x,levels,ordered) . args(factor) . &lt;pre class=language-r&gt;function (x = character(), levels, labels = levels, exclude = NA, &lt;span style=white-space:pre-wrap&gt; ordered = is.ordered(x), nmax = NA) &lt;/span&gt; NULL&lt;/pre&gt; Ogender&lt;-factor(gender,levels=c(&#39;woman&#39;,&#39;man&#39;),ordered = TRUE) Ogender # factor 함수에서 사용할 수 있는 매개변수를 확인하고, 해당 변수를 이용하여 순서 잇는 요인형으로 변환한 후 Levels:에서 범주의 순서를 확인할 수 있다. # 전에는 man이 먼저 나왔는데 이번엔 woman이 먼저 나온 것을 확인할 수 있다. . &lt;ol class=list-inline&gt;man | woman | woman | man | man | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt;&#39;woman&#39; | &#39;man&#39; | &lt;/ol&gt; par(mfrow=c(1,2)) # 두 개의 그래프를 Plots 영역에 나타낼 수 있다. # (2,2)라고 바꿔주면 4개의 그래프를 그릴 수 있다. plot(Ngender) plot(Ogender) . . 날짜형 변환 : 인터넷 또는 로컬 파일로부터 가져온 자료 중에서 날짜형 칼럼은 요인형 또는 문자형으로 인식되기 때문에 정확한 날짜형으로 변환할 필요가 있다. | . a=as.Date(&#39;20/02/28&#39;,&#39;%y/%m/%d&#39;) a class(a) . 2020-02-28 &#39;Date&#39; dates=c(&#39;15/02/24&#39;,&#39;10/02/2&#39;,&#39;16/08/14&#39;) as.Date(dates,&#39;%y/%m/%d&#39;) . &lt;ol class=list-inline&gt;2015-02-24 | 2010-02-02 | 2016-08-14 | &lt;/ol&gt; dates=c(&#39;15/22/24&#39;,&#39;98/02/2&#39;,&#39;16/08/14&#39;) as.Date(dates,&#39;%y/%m/%d&#39;) . &lt;ol class=list-inline&gt;&lt;NA&gt; | 1998-02-02 | 2016-08-14 | &lt;/ol&gt; 22월이라는 날짜는 없으므로 NA처리 되었다. | 년도 4자리로 작성 : %Y | 년도 2자리로 작성 : %y | 24시간 : %H | 12시간 : %I | 분 : %M | 초 : %S | . . 현재 날짜와 시간 확인 | . a=Sys.time() mode(a) class(a) . &#39;numeric&#39; &lt;ol class=list-inline&gt;&#39;POSIXct&#39; | &#39;POSIXt&#39; | &lt;/ol&gt; strptime()를 이용한 날짜형 변환 | . sdate&lt;-&#39;2019-11-11 12:17:6&#39; class(sdate) today&lt;-strptime(sdate,format=&#39;%Y-%m-%d %H:%M:%S&#39;) today class(today) . &#39;character&#39; [1] &#34;2019-11-11 12:17:06 KST&#34; . &lt;ol class=list-inline&gt;&#39;POSIXlt&#39; | &#39;POSIXt&#39; | &lt;/ol&gt; 반면 as.Date()는 날짜 자료만 형 변환이 가능하다. | . . 기본 함수와 작업공간 R 패키지에서 제공되는 수많은 함수 사용법을 머릿속에 기억하기는 불가능한 일이다. 따라서 해당 함수의 사용법을 제공하는 도움말 기능을 이용할 수 있어야 한다. | &#39;help(함수명)&#39; 또는 &#39;?함수명&#39;형식으로 볼 수 있다. | 파이썬에서는 &#39;함수명?&#39;이다. | google에서는 &#39;함수명() in r&#39; 형식으로 검색한 뒤 확인할 수 있다. | . | arg(함수명) : 특정 함수를 대상으로 사용 가능한 함수 파라미터를 보여준다. 예를 들어보자 | . | . args(max) # na.rm은 FALSE가 default이다. . &lt;pre class=language-r&gt;function (..., na.rm = FALSE) NULL&lt;/pre&gt; example() 함수는 R에서 제공되는 기본 함수들을 사용하는 예제를 제공해준다. | . example(seq) . seq&gt; seq(0, 1, length.out = 11) [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 seq&gt; seq(stats::rnorm(20)) # effectively &#39;along&#39; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq&gt; seq(1, 9, by = 2) # matches &#39;end&#39; [1] 1 3 5 7 9 seq&gt; seq(1, 9, by = pi) # stays below &#39;end&#39; [1] 1.000000 4.141593 7.283185 seq&gt; seq(1, 6, by = 3) [1] 1 4 seq&gt; seq(1.575, 5.125, by = 0.05) [1] 1.575 1.625 1.675 1.725 1.775 1.825 1.875 1.925 1.975 2.025 2.075 2.125 [13] 2.175 2.225 2.275 2.325 2.375 2.425 2.475 2.525 2.575 2.625 2.675 2.725 [25] 2.775 2.825 2.875 2.925 2.975 3.025 3.075 3.125 3.175 3.225 3.275 3.325 [37] 3.375 3.425 3.475 3.525 3.575 3.625 3.675 3.725 3.775 3.825 3.875 3.925 [49] 3.975 4.025 4.075 4.125 4.175 4.225 4.275 4.325 4.375 4.425 4.475 4.525 [61] 4.575 4.625 4.675 4.725 4.775 4.825 4.875 4.925 4.975 5.025 5.075 5.125 seq&gt; seq(17) # same as 1:17, or even better seq_len(17) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . seq() 함수를 사용하는 예로 다양한 방법으로 벡터 원소를 생성하는 과정을 보여준다. | mean의 예제도 알아보자 | . example(mean) . mean&gt; x &lt;- c(0:10, 50) mean&gt; xm &lt;- mean(x) mean&gt; c(xm, mean(x, trim = 0.10)) [1] 8.75 5.50 .",
            "url": "https://rhkrehtjd.github.io/INTROr/2022/02/04/R.html",
            "relUrl": "/2022/02/04/R.html",
            "date": " • Feb 4, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rhkrehtjd.github.io/INTROr/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rhkrehtjd.github.io/INTROr/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}